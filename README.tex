\documentclass[11pt]{article}
\usepackage{amsmath,amsfonts,amsthm,alltt,amssymb}
\textheight 8.5in
\topmargin -0.2in
\oddsidemargin 0.2in
\textwidth 6.3in

\usepackage{cancel}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{graphicx}
% \graphicspath{ {images/} }

%% These allow you to define and reference things like theorems, lemmas, etc.

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{warning}[theorem]{Warning}
\newtheorem{case}{Case}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}


%% Here are some useful definitions.

\def\prob#1#2{{\mathbb{P}}_{#1}\left[ #2 \right]}


\def\defeq{\stackrel{\mathrm{def}}{=}}
\def\setof#1{\left\{#1  \right\}}
\def\sizeof#1{\left|#1  \right|}

\def\floor#1{\left\lfloor #1 \right\rfloor}
\def\ceil#1{\left\lceil #1 \right\rceil}

\def\union{\cup}
\def\intersect{\cap}
\def\Union{\bigcup}
\def\Intersect{\bigcap}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}


\def\form#1#2{\left\langle #1, #2\right\rangle}

\def\abs#1{\left|#1  \right|}


\def\norm#1{\left\| #1 \right\|}
\def\smallnorm#1{\| #1 \|}


%% When I want to write complicated symbols often, I always make definitions for them.

\def\Ahat{\widehat{A}}
\def\Bhat{\widehat{B}}
\def\Ehat{\widehat{E}}
\def\Ghat{\widehat{G}}
\def\Vhat{\widehat{V}}
\def\xhat{\widehat{x}}
\def\fishij{\alpha_{i,j}}
\def\ABC{A \union B \union C}

\def\Mhatpi{$\widehat{M}_{\pi}$}

\def\Mhatprime{$\widehat{M}_{\pi'}$}

\def\destroynode{destroy\_node}

\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

%%%---------------------------------------------
%%%  begin document
%%%


\begin{document}
\begin{center}
{\Large 
Hamiltonian Cycle on Cube n}
\end{center}

\begin{definition}
A \textit{cube n} is a graph $G = (V,E)$ where
\[
V = \setof{1,2,\dots,2^n}
\]
\[
E = \setof{u,v \in V \mid \text{the binary representations of u and v differ in exactly one place}}
\]
\end{definition}

\begin{definition}
A \text{Hamiltonian cycle} is a path that touches each node exactly once.
\end{definition}

We provide (see Racket file) a linear time $O(|V|)$ algorithm to find a Hamiltonian cycle on the cube n. The algorithm prints out nodes represented in binary in the order the path takes. Using the file, one can check empirically that all two adjacent nodes differ in exactly one spot, and that each node is visited once.

It's in linear time since we have the recurrence $T(M) \leq T(\frac{M}{2}) + CM$ where $M = |V| = 2^n$ and $C$ is some constant.

It's correct by induction on $n$. For $n = 1$, we output $0,1$, visiting each of the $2^1$ nodes. Assuming we have a hamiltonian cycle for $n-1$, we append the $zerolist$ to the $onelist$. This means each node will still differ in exactly one place, and that we will visit each of $2^n$ binary-represented nodes, completing the induction.

\end{document}